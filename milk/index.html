<!doctype html>
<html>

<head>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #4a5942;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="myCanvas"></canvas>
  <script>
    const U_FIELD = 0;
    const V_FIELD = 1;
    const FLUID_CELL = 0;
    const AIR_CELL = 1;
    const SOLID_CELL = 2;

    function clamp(val, min, max) {
      return val < min ? min : val > max ? max : val;
    }

    class FlipFluid {
      constructor(density, width, height, spacing, particleRadius, maxParticles) {
        this.density = density;
        this.fNumX = Math.floor(width / spacing) + 1;
        this.fNumY = Math.floor(height / spacing) + 1;
        this.h = Math.max(width / this.fNumX, height / this.fNumY);
        this.fInvSpacing = 1 / this.h;
        this.fNumCells = this.fNumX * this.fNumY;

        this.u = new Float32Array(this.fNumCells);
        this.v = new Float32Array(this.fNumCells);
        this.du = new Float32Array(this.fNumCells);
        this.dv = new Float32Array(this.fNumCells);
        this.prevU = new Float32Array(this.fNumCells);
        this.prevV = new Float32Array(this.fNumCells);

        this.p = new Float32Array(this.fNumCells);
        this.s = new Float32Array(this.fNumCells);
        this.cellType = new Int32Array(this.fNumCells);
        this.cellColor = new Float32Array(3 * this.fNumCells);

        this.maxParticles = maxParticles;
        this.particlePos = new Float32Array(2 * this.maxParticles);
        this.particleColor = new Float32Array(3 * this.maxParticles);
        for (let i = 0; i < this.maxParticles; i++) {
          this.particleColor[3 * i + 2] = 1.0;
        }
        this.particleVel = new Float32Array(2 * this.maxParticles);
        this.particleDensity = new Float32Array(this.fNumCells);
        this.particleRestDensity = 0;
        this.numParticles = 0;

        this.particleRadius = particleRadius;
        this.pInvSpacing = 1 / (2.2 * particleRadius);
        this.pNumX = Math.floor(width * this.pInvSpacing) + 1;
        this.pNumY = Math.floor(height * this.pInvSpacing) + 1;
        this.pNumCells = this.pNumX * this.pNumY;
        this.numCellParticles = new Int32Array(this.pNumCells);
        this.firstCellParticle = new Int32Array(this.pNumCells + 1);
        this.cellParticleIds = new Int32Array(maxParticles);
      }

      integrateParticles(dt, gravity) {
        for (let i = 0; i < this.numParticles; i++) {
          this.particleVel[2 * i + 1] += dt * gravity;
          this.particlePos[2 * i] += this.particleVel[2 * i] * dt;
          this.particlePos[2 * i + 1] += this.particleVel[2 * i + 1] * dt;
        }
      }

      pushParticlesApart(numIters) {
        this.numCellParticles.fill(0);

        for (let i = 0; i < this.numParticles; i++) {
          const x = this.particlePos[2 * i];
          const y = this.particlePos[2 * i + 1];
          const xi = clamp(Math.floor(x * this.pInvSpacing), 0, this.pNumX - 1);
          const yi = clamp(Math.floor(y * this.pInvSpacing), 0, this.pNumY - 1);
          const cellNr = xi * this.pNumY + yi;
          this.numCellParticles[cellNr]++;
        }

        let first = 0;
        for (let i = 0; i < this.pNumCells; i++) {
          first += this.numCellParticles[i];
          this.firstCellParticle[i] = first;
        }
        this.firstCellParticle[this.pNumCells] = first;

        for (let i = 0; i < this.numParticles; i++) {
          const x = this.particlePos[2 * i];
          const y = this.particlePos[2 * i + 1];
          const xi = clamp(Math.floor(x * this.pInvSpacing), 0, this.pNumX - 1);
          const yi = clamp(Math.floor(y * this.pInvSpacing), 0, this.pNumY - 1);
          const cellNr = xi * this.pNumY + yi;
          this.firstCellParticle[cellNr]--;
          this.cellParticleIds[this.firstCellParticle[cellNr]] = i;
        }

        const minDist = 2.0 * this.particleRadius;
        const minDist2 = minDist * minDist;

        for (let iter = 0; iter < numIters; iter++) {
          for (let i = 0; i < this.numParticles; i++) {
            const px = this.particlePos[2 * i];
            const py = this.particlePos[2 * i + 1];

            const pxi = Math.floor(px * this.pInvSpacing);
            const pyi = Math.floor(py * this.pInvSpacing);
            const x0 = Math.max(pxi - 1, 0);
            const y0 = Math.max(pyi - 1, 0);
            const x1 = Math.min(pxi + 1, this.pNumX - 1);
            const y1 = Math.min(pyi + 1, this.pNumY - 1);

            for (let xi = x0; xi <= x1; xi++) {
              for (let yi = y0; yi <= y1; yi++) {
                const cellNr = xi * this.pNumY + yi;
                const first = this.firstCellParticle[cellNr];
                const last = this.firstCellParticle[cellNr + 1];

                for (let j = first; j < last; j++) {
                  const id = this.cellParticleIds[j];
                  if (id === i) continue;

                  const qx = this.particlePos[2 * id];
                  const qy = this.particlePos[2 * id + 1];

                  const dx = qx - px;
                  const dy = qy - py;
                  const d2 = dx * dx + dy * dy;

                  if (d2 > minDist2 || d2 === 0.0) continue;

                  const d = Math.sqrt(d2);
                  const s = 0.5 * (minDist - d) / d;
                  const moveX = dx * s;
                  const moveY = dy * s;

                  this.particlePos[2 * i] -= moveX;
                  this.particlePos[2 * i + 1] -= moveY;
                  this.particlePos[2 * id] += moveX;
                  this.particlePos[2 * id + 1] += moveY;

                  for (let k = 0; k < 3; k++) {
                    const col0 = this.particleColor[3 * i + k];
                    const col1 = this.particleColor[3 * id + k];
                    const avg = 0.5 * (col0 + col1);
                    this.particleColor[3 * i + k] = col0 + 0.001 * (avg - col0);
                    this.particleColor[3 * id + k] = col1 + 0.001 * (avg - col1);
                  }
                }
              }
            }
          }
        }
      }

      handleParticleCollisions(obstacleX, obstacleY, obstacleRadius) {
        const h = 1.0 / this.fInvSpacing;
        const r = this.particleRadius;
        const minX = h + r;
        const maxX = (this.fNumX - 1) * h - r;
        const minY = h + r;
        const maxY = (this.fNumY - 1) * h - r;

        for (let i = 0; i < this.numParticles; i++) {
          let x = this.particlePos[2 * i];
          let y = this.particlePos[2 * i + 1];

          const dx = x - obstacleX;
          const dy = y - obstacleY;
          const d2 = dx * dx + dy * dy;

          if (d2 < (obstacleRadius + r) * (obstacleRadius + r)) {
            this.particleVel[2 * i] = scene.obstacleVelX;
            this.particleVel[2 * i + 1] = scene.obstacleVelY;
          }

          if (x < minX) {
            x = minX;
            this.particleVel[2 * i] = 0;
          }
          if (x > maxX) {
            x = maxX;
            this.particleVel[2 * i] = 0;
          }
          if (y < minY) {
            y = minY;
            this.particleVel[2 * i + 1] = 0;
          }
          if (y > maxY) {
            y = maxY;
            this.particleVel[2 * i + 1] = 0;
          }

          this.particlePos[2 * i] = x;
          this.particlePos[2 * i + 1] = y;
        }
      }

      updateParticleDensity() {
        const n = this.fNumY;
        const h = this.h;
        const h1 = this.fInvSpacing;
        const h2 = 0.5 * h;
        const d = this.particleDensity;
        d.fill(0);

        for (let i = 0; i < this.numParticles; i++) {
          let x = this.particlePos[2 * i];
          let y = this.particlePos[2 * i + 1];

          x = clamp(x, h, (this.fNumX - 1) * h);
          y = clamp(y, h, (this.fNumY - 1) * h);

          const x0 = Math.floor((x - h2) * h1);
          const tx = ((x - h2) - x0 * h) * h1;
          const x1 = Math.min(x0 + 1, this.fNumX - 2);

          const y0 = Math.floor((y - h2) * h1);
          const ty = ((y - h2) - y0 * h) * h1;
          const y1 = Math.min(y0 + 1, this.fNumY - 2);

          const sx = 1.0 - tx;
          const sy = 1.0 - ty;

          if (x0 < this.fNumX && y0 < this.fNumY) d[x0 * n + y0] += sx * sy;
          if (x1 < this.fNumX && y0 < this.fNumY) d[x1 * n + y0] += tx * sy;
          if (x1 < this.fNumX && y1 < this.fNumY) d[x1 * n + y1] += tx * ty;
          if (x0 < this.fNumX && y1 < this.fNumY) d[x0 * n + y1] += sx * ty;
        }

        if (this.particleRestDensity === 0) {
          let sum = 0.0;
          let numFluidCells = 0;

          for (let i = 0; i < this.fNumCells; i++) {
            if (this.cellType[i] === FLUID_CELL) {
              sum += d[i];
              numFluidCells++;
            }
          }

          if (numFluidCells > 0) {
            this.particleRestDensity = sum / numFluidCells;
          }
        }
      }

      transferVelocities(toGrid, flipRatio) {
        const n = this.fNumY;
        const h = this.h;
        const h1 = this.fInvSpacing;
        const h2 = 0.5 * h;

        if (toGrid) {
          this.prevU.set(this.u);
          this.prevV.set(this.v);
          this.du.fill(0);
          this.dv.fill(0);
          this.u.fill(0);
          this.v.fill(0);

          for (let i = 0; i < this.fNumCells; i++) {
            this.cellType[i] = this.s[i] === 0.0 ? SOLID_CELL : AIR_CELL;
          }

          for (let i = 0; i < this.numParticles; i++) {
            const x = this.particlePos[2 * i];
            const y = this.particlePos[2 * i + 1];
            const xi = clamp(Math.floor(x * h1), 0, this.fNumX - 1);
            const yi = clamp(Math.floor(y * h1), 0, this.fNumY - 1);
            const cellNr = xi * n + yi;

            if (this.cellType[cellNr] === AIR_CELL) {
              this.cellType[cellNr] = FLUID_CELL;
            }
          }
        }

        for (let component = 0; component < 2; component++) {
          const dx = component === 0 ? 0.0 : h2;
          const dy = component === 0 ? h2 : 0.0;

          const f = component === 0 ? this.u : this.v;
          const prevF = component === 0 ? this.prevU : this.prevV;
          const d = component === 0 ? this.du : this.dv;

          for (let i = 0; i < this.numParticles; i++) {
            let x = this.particlePos[2 * i];
            let y = this.particlePos[2 * i + 1];

            x = clamp(x, h, (this.fNumX - 1) * h);
            y = clamp(y, h, (this.fNumY - 1) * h);

            const x0 = Math.min(Math.floor((x - dx) * h1), this.fNumX - 2);
            const tx = ((x - dx) - x0 * h) * h1;
            const x1 = Math.min(x0 + 1, this.fNumX - 2);

            const y0 = Math.min(Math.floor((y - dy) * h1), this.fNumY - 2);
            const ty = ((y - dy) - y0 * h) * h1;
            const y1 = Math.min(y0 + 1, this.fNumY - 2);

            const sx = 1.0 - tx;
            const sy = 1.0 - ty;

            const d0 = sx * sy;
            const d1 = tx * sy;
            const d2 = tx * ty;
            const d3 = sx * ty;

            const nr0 = x0 * n + y0;
            const nr1 = x1 * n + y0;
            const nr2 = x1 * n + y1;
            const nr3 = x0 * n + y1;

            if (toGrid) {
              const pv = this.particleVel[2 * i + component];
              f[nr0] += pv * d0;
              d[nr0] += d0;
              f[nr1] += pv * d1;
              d[nr1] += d1;
              f[nr2] += pv * d2;
              d[nr2] += d2;
              f[nr3] += pv * d3;
              d[nr3] += d3;
            } else {
              const offset = component === 0 ? n : 1;
              const valid0 = this.cellType[nr0] !== AIR_CELL || this.cellType[nr0 - offset] !== AIR_CELL ? 1.0 : 0.0;
              const valid1 = this.cellType[nr1] !== AIR_CELL || this.cellType[nr1 - offset] !== AIR_CELL ? 1.0 : 0.0;
              const valid2 = this.cellType[nr2] !== AIR_CELL || this.cellType[nr2 - offset] !== AIR_CELL ? 1.0 : 0.0;
              const valid3 = this.cellType[nr3] !== AIR_CELL || this.cellType[nr3 - offset] !== AIR_CELL ? 1.0 : 0.0;

              let v = this.particleVel[2 * i + component];
              const divisor = valid0 * d0 + valid1 * d1 + valid2 * d2 + valid3 * d3;

              if (divisor > 0.0) {
                const picV = (valid0 * d0 * f[nr0] + valid1 * d1 * f[nr1] + valid2 * d2 * f[nr2] + valid3 * d3 * f[nr3]) / divisor;
                const corr = (valid0 * d0 * (f[nr0] - prevF[nr0]) + valid1 * d1 * (f[nr1] - prevF[nr1]) +
                  valid2 * d2 * (f[nr2] - prevF[nr2]) + valid3 * d3 * (f[nr3] - prevF[nr3])) / divisor;
                const flipV = v + corr;

                this.particleVel[2 * i + component] = (1.0 - flipRatio) * picV + flipRatio * flipV;
              }
            }
          }

          if (toGrid) {
            for (let i = 0; i < f.length; i++) {
              if (d[i] > 0.0) f[i] /= d[i];
            }

            for (let i = 0; i < this.fNumX; i++) {
              for (let j = 0; j < this.fNumY; j++) {
                const solid = this.cellType[i * n + j] === SOLID_CELL;
                if (solid || (i > 0 && this.cellType[(i - 1) * n + j] === SOLID_CELL))
                  this.u[i * n + j] = this.prevU[i * n + j];
                if (solid || (j > 0 && this.cellType[i * n + j - 1] === SOLID_CELL))
                  this.v[i * n + j] = this.prevV[i * n + j];
              }
            }
          }
        }
      }

      solveIncompressibility(numIters, dt, overRelaxation, compensateDrift = true) {
        this.p.fill(0);
        this.prevU.set(this.u);
        this.prevV.set(this.v);

        const n = this.fNumY;
        const cp = this.density * this.h / dt;

        for (let iter = 0; iter < numIters; iter++) {
          for (let i = 1; i < this.fNumX - 1; i++) {
            for (let j = 1; j < this.fNumY - 1; j++) {
              if (this.cellType[i * n + j] !== FLUID_CELL) continue;

              const center = i * n + j;
              const left = (i - 1) * n + j;
              const right = (i + 1) * n + j;
              const bottom = i * n + (j - 1);
              const top = i * n + (j + 1);

              let s = this.s[center];
              const sx0 = this.s[left];
              const sx1 = this.s[right];
              const sy0 = this.s[bottom];
              const sy1 = this.s[top];
              s = sx0 + sx1 + sy0 + sy1;

              if (s === 0.0) continue;

              let div = this.u[right] - this.u[center] + this.v[top] - this.v[center];

              if (this.particleRestDensity > 0.0 && compensateDrift) {
                const compression = this.particleDensity[i * n + j] - this.particleRestDensity;
                if (compression > 0.0) {
                  div -= compression;
                }
              }

              const p = -div / s * overRelaxation;
              this.p[center] += cp * p;
              this.u[center] -= sx0 * p;
              this.u[right] += sx1 * p;
              this.v[center] -= sy0 * p;
              this.v[top] += sy1 * p;
            }
          }
        }
      }

      updateParticleColors() {
        const h1 = this.fInvSpacing;

        for (let i = 0; i < this.numParticles; i++) {
          const s = 0.01;
          this.particleColor[3 * i] = clamp(this.particleColor[3 * i] + s, 0.8, 1.0);
          this.particleColor[3 * i + 1] = clamp(this.particleColor[3 * i + 1] + s, 0.8, 1.0);
          this.particleColor[3 * i + 2] = clamp(this.particleColor[3 * i + 2] - s, 0.7, 0.9);

          const x = this.particlePos[2 * i];
          const y = this.particlePos[2 * i + 1];
          const xi = clamp(Math.floor(x * h1), 1, this.fNumX - 1);
          const yi = clamp(Math.floor(y * h1), 1, this.fNumY - 1);
          const cellNr = xi * this.fNumY + yi;

          const restDensity = this.particleRestDensity;
          if (restDensity > 0.0) {
            const relDensity = this.particleDensity[cellNr] / restDensity;
            if (relDensity < 0.7) {
              const s = 0.95;
              this.particleColor[3 * i] = s;
              this.particleColor[3 * i + 1] = s;
              this.particleColor[3 * i + 2] = 0.85;
            }
          }
        }
      }

      setSciColor(cellNr, val, minVal, maxVal) {
        val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
        const d = maxVal - minVal;
        val = d === 0.0 ? 0.5 : (val - minVal) / d;
        const m = 0.25;
        const num = Math.floor(val / m);
        const s = (val - num * m) / m;
        let r, g, b;

        switch (num) {
          case 0: r = 0.0; g = s; b = 1.0; break;
          case 1: r = 0.0; g = 1.0; b = 1.0 - s; break;
          case 2: r = s; g = 1.0; b = 0.0; break;
          case 3: r = 1.0; g = 1.0 - s; b = 0.0; break;
        }

        this.cellColor[3 * cellNr] = r;
        this.cellColor[3 * cellNr + 1] = g;
        this.cellColor[3 * cellNr + 2] = b;
      }

      updateCellColors() {
        this.cellColor.fill(0);

        for (let i = 0; i < this.fNumCells; i++) {
          if (this.cellType[i] === SOLID_CELL) {
            this.cellColor[3 * i] = 0.5;
            this.cellColor[3 * i + 1] = 0.5;
            this.cellColor[3 * i + 2] = 0.5;
          } else if (this.cellType[i] === FLUID_CELL) {
            let d = this.particleDensity[i];
            if (this.particleRestDensity > 0.0) {
              d /= this.particleRestDensity;
            }
            this.setSciColor(i, d, 0.0, 2.0);
          }
        }
      }

      simulate(dt, gravity, flipRatio, numPressureIters, numParticleIters, overRelaxation,
        compensateDrift, separateParticles, obstacleX, obstacleY, obstacleRadius) {
        const numSubSteps = 1;
        const sdt = dt / numSubSteps;

        for (let step = 0; step < numSubSteps; step++) {
          this.integrateParticles(sdt, gravity);
          if (separateParticles) {
            this.pushParticlesApart(numParticleIters);
          }
          this.handleParticleCollisions(obstacleX, obstacleY, obstacleRadius);
          this.transferVelocities(true, flipRatio);
          this.updateParticleDensity();
          this.solveIncompressibility(numPressureIters, sdt, overRelaxation, compensateDrift);
          this.transferVelocities(false, flipRatio);
        }

        this.updateParticleColors();
        this.updateCellColors();
      }
    }

    const scene = {
      gravity: -9.81,
      dt: 1 / 60,
      host_timescale: 1.0,
      flipRatio: 0.9,
      numPressureIters: 30,
      numParticleIters: 1,
      overRelaxation: 1.9,
      compensateDrift: true,
      separateParticles: true,
      obstacleX: 0,
      obstacleY: 0,
      obstacleRadius: 0.5,
      paused: false,
      obstacleVelX: 0,
      obstacleVelY: 0,
      showParticles: true,
      showGrid: false,
      fluid: null
    };

    const canvas = document.getElementById('myCanvas');
    const gl = canvas.getContext('webgl');
    canvas.width = window.innerWidth - 20;
    canvas.height = window.innerHeight - 20;

    const simHeight = 13;
    const cScale = canvas.height / simHeight;
    const simWidth = canvas.width / cScale;

    const pointVertexShader = `
      attribute vec2 attrPosition;
      attribute vec3 attrColor;
      uniform vec2 domainSize;
      uniform float pointSize;
      uniform float drawDisk;
      varying vec3 fragColor;
      varying float fragDrawDisk;

      void main() {
        vec4 screenTransform = vec4(2.0 / domainSize.x, 2.0 / domainSize.y, -1.0, -1.0);
        gl_Position = vec4(attrPosition * screenTransform.xy + screenTransform.zw, 0.0, 1.0);
        gl_PointSize = pointSize;
        fragColor = attrColor;
        fragDrawDisk = drawDisk;
      }
    `;

    const pointFragmentShader = `
      precision mediump float;
      varying vec3 fragColor;
      varying float fragDrawDisk;

      void main() {
        if (fragDrawDisk == 1.0) {
          float rx = 0.5 - gl_PointCoord.x;
          float ry = 0.5 - gl_PointCoord.y;
          float r2 = rx * rx + ry * ry;
          if (r2 > 0.25) discard;
        }
        gl_FragColor = vec4(fragColor, 1.0);
      }
    `;

    const meshVertexShader = `
      attribute vec2 attrPosition;
      uniform vec2 domainSize;
      uniform vec3 color;
      uniform vec2 translation;
      uniform float scale;
      varying vec3 fragColor;

      void main() {
        vec2 v = translation + attrPosition * scale;
        vec4 screenTransform = vec4(2.0 / domainSize.x, 2.0 / domainSize.y, -1.0, -1.0);
        gl_Position = vec4(v * screenTransform.xy + screenTransform.zw, 0.0, 1.0);
        fragColor = color;
      }
    `;

    const meshFragmentShader = `
      precision mediump float;
      varying vec3 fragColor;

      void main() {
        gl_FragColor = vec4(fragColor, 1.0);
      }
    `;

    function createShader(gl, vertexSource, fragmentSource) {
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vertexSource);
      gl.compileShader(vertexShader);

      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.error('Vertex shader error:', gl.getShaderInfoLog(vertexShader));
      }

      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentSource);
      gl.compileShader(fragmentShader);

      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.error('Fragment shader error:', gl.getShaderInfoLog(fragmentShader));
      }

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      return program;
    }

    let pointShader = null;
    let meshShader = null;
    let pointVertexBuffer = null;
    let pointColorBuffer = null;
    let gridVertBuffer = null;
    let gridColorBuffer = null;
    let circleVertexBuffer = null;

    function draw() {
      gl.clearColor(0.29, 0.349, 0.259, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, canvas.width, canvas.height);

      if (!pointShader) {
        pointShader = createShader(gl, pointVertexShader, pointFragmentShader);
      }

      if (!meshShader) {
        meshShader = createShader(gl, meshVertexShader, meshFragmentShader);
      }

      const fluid = scene.fluid;
      if (!fluid) return;

      if (!gridVertBuffer) {
        gridVertBuffer = gl.createBuffer();
        const vertices = new Float32Array(2 * fluid.fNumCells);
        let idx = 0;
        for (let i = 0; i < fluid.fNumX; i++) {
          for (let j = 0; j < fluid.fNumY; j++) {
            vertices[idx++] = (i + 0.5) * fluid.h;
            vertices[idx++] = (j + 0.5) * fluid.h;
          }
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, gridVertBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      if (!gridColorBuffer) {
        gridColorBuffer = gl.createBuffer();
      }

      if (scene.showGrid) {
        const pointSize = 0.9 * fluid.h / simWidth * canvas.width;
        gl.useProgram(pointShader);
        gl.uniform2f(gl.getUniformLocation(pointShader, 'domainSize'), simWidth, simHeight);
        gl.uniform1f(gl.getUniformLocation(pointShader, 'pointSize'), pointSize);
        gl.uniform1f(gl.getUniformLocation(pointShader, 'drawDisk'), 0.0);

        gl.bindBuffer(gl.ARRAY_BUFFER, gridVertBuffer);
        const posAttr = gl.getAttribLocation(pointShader, 'attrPosition');
        gl.enableVertexAttribArray(posAttr);
        gl.vertexAttribPointer(posAttr, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, gridColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, fluid.cellColor, gl.DYNAMIC_DRAW);
        const colorAttr = gl.getAttribLocation(pointShader, 'attrColor');
        gl.enableVertexAttribArray(colorAttr);
        gl.vertexAttribPointer(colorAttr, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.POINTS, 0, fluid.fNumCells);
        gl.disableVertexAttribArray(posAttr);
        gl.disableVertexAttribArray(colorAttr);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      if (scene.showParticles) {
        gl.clear(gl.DEPTH_BUFFER_BIT);
        const pointSize = 2.0 * fluid.particleRadius / simWidth * canvas.width;

        gl.useProgram(pointShader);
        gl.uniform2f(gl.getUniformLocation(pointShader, 'domainSize'), simWidth, simHeight);
        gl.uniform1f(gl.getUniformLocation(pointShader, 'pointSize'), pointSize);
        gl.uniform1f(gl.getUniformLocation(pointShader, 'drawDisk'), 1.0);

        if (!pointVertexBuffer) {
          pointVertexBuffer = gl.createBuffer();
        }
        if (!pointColorBuffer) {
          pointColorBuffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, pointVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, fluid.particlePos, gl.DYNAMIC_DRAW);
        const posAttr = gl.getAttribLocation(pointShader, 'attrPosition');
        gl.enableVertexAttribArray(posAttr);
        gl.vertexAttribPointer(posAttr, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, pointColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, fluid.particleColor, gl.DYNAMIC_DRAW);
        const colorAttr = gl.getAttribLocation(pointShader, 'attrColor');
        gl.enableVertexAttribArray(colorAttr);
        gl.vertexAttribPointer(colorAttr, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.POINTS, 0, fluid.numParticles);
        gl.disableVertexAttribArray(posAttr);
        gl.disableVertexAttribArray(colorAttr);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      if (!circleVertexBuffer) {
        const segments = 32;
        const vertices = new Float32Array((segments + 2) * 2);
        vertices[0] = 0;
        vertices[1] = 0;
        for (let i = 0; i <= segments; i++) {
          const angle = (i / segments) * Math.PI * 2;
          vertices[(i + 1) * 2] = Math.cos(angle);
          vertices[(i + 1) * 2 + 1] = Math.sin(angle);
        }
        circleVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, circleVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      gl.useProgram(meshShader);
      gl.uniform2f(gl.getUniformLocation(meshShader, 'domainSize'), simWidth, simHeight);
      gl.uniform3f(gl.getUniformLocation(meshShader, 'color'), 1.0, 0.4, 0.7);
      gl.uniform2f(gl.getUniformLocation(meshShader, 'translation'), scene.obstacleX, scene.obstacleY);
      gl.uniform1f(gl.getUniformLocation(meshShader, 'scale'), scene.obstacleRadius);

      gl.bindBuffer(gl.ARRAY_BUFFER, circleVertexBuffer);
      const meshPosAttr = gl.getAttribLocation(meshShader, 'attrPosition');
      gl.enableVertexAttribArray(meshPosAttr);
      gl.vertexAttribPointer(meshPosAttr, 2, gl.FLOAT, false, 0, 0);

      gl.drawArrays(gl.TRIANGLE_FAN, 0, 34);
      gl.disableVertexAttribArray(meshPosAttr);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }

    function setObstacle(x, y, reset) {
      let vx = 0;
      let vy = 0;

      if (!reset) {
        vx = (x - scene.obstacleX) / scene.dt;
        vy = (y - scene.obstacleY) / scene.dt;
      }

      scene.obstacleX = x;
      scene.obstacleY = y;

      const r = scene.obstacleRadius;
      const fluid = scene.fluid;
      const n = fluid.fNumY;
      const h = fluid.h;

      for (let i = 1; i < fluid.fNumX - 2; i++) {
        for (let j = 1; j < fluid.fNumY - 2; j++) {
          fluid.s[i * n + j] = 1.0;

          const dx = (i + 0.5) * h - x;
          const dy = (j + 0.5) * h - y;

          if (dx * dx + dy * dy < r * r) {
            fluid.s[i * n + j] = 0.0;
            fluid.u[i * n + j] = vx;
            fluid.u[(i + 1) * n + j] = vx;
            fluid.v[i * n + j] = vy;
            fluid.v[i * n + j + 1] = vy;
          }
        }
      }

      scene.obstacleVelX = vx;
      scene.obstacleVelY = vy;
    }

    function setupScene() {
      scene.obstacleRadius = 0.5;
      scene.overRelaxation = 1.9;
      scene.dt = 1 / 60;
      scene.numPressureIters = 30;
      scene.numParticleIters = 1;

      const width = simWidth;
      const height = simHeight;
      const spacing = height / 100;
      const particleRadius = 0.2 * spacing;
      const pDiam = 2.0 * particleRadius;
      const pSpacing = Math.sqrt(3) / 2.0 * pDiam;

      const numX = Math.floor((0.4 * width - 2 * spacing - 2 * particleRadius) / pDiam);
      const numY = Math.floor((0.8 * height - 2 * spacing - 2 * particleRadius) / pSpacing);
      const maxParticles = numX * numY;

      const fluid = new FlipFluid(1000, width, height, spacing, particleRadius, maxParticles);
      fluid.numParticles = numX * numY;

      let p = 0;
      for (let i = 0; i < numX; i++) {
        for (let j = 0; j < numY; j++) {
          fluid.particlePos[p++] = spacing + particleRadius + pDiam * i + (j % 2 === 0 ? 0 : particleRadius);
          fluid.particlePos[p++] = spacing + particleRadius + pSpacing * j;
        }
      }

      const n = fluid.fNumY;
      for (let i = 0; i < fluid.fNumX; i++) {
        for (let j = 0; j < fluid.fNumY; j++) {
          let s = 1.0;
          if (i === 0 || i === fluid.fNumX - 1 || j === 0) {
            s = 0.0;
          }
          fluid.s[i * n + j] = s;
        }
      }

      scene.fluid = fluid;
      setObstacle(simWidth / 2, simHeight / 2, true);
    }

    let mouseDown = false;

    function startDrag(x, y) {
      const rect = canvas.getBoundingClientRect();
      const cx = x - rect.left - canvas.clientLeft;
      const cy = y - rect.top - canvas.clientTop;
      const sx = cx / cScale;
      const sy = (canvas.height - cy) / cScale;
      mouseDown = true;
      setObstacle(sx, sy, false);
    }

    function drag(x, y) {
      if (mouseDown) {
        const rect = canvas.getBoundingClientRect();
        const cx = x - rect.left - canvas.clientLeft;
        const cy = y - rect.top - canvas.clientTop;
        const sx = cx / cScale;
        const sy = (canvas.height - cy) / cScale;
        setObstacle(sx, sy, false);
      }
    }

    function endDrag() {
      mouseDown = false;
      scene.obstacleVelX = 0;
      scene.obstacleVelY = 0;
    }

    canvas.addEventListener('mousedown', (e) => {
      startDrag(e.clientX, e.clientY);
    });

    canvas.addEventListener('mousemove', (e) => {
      drag(e.clientX, e.clientY);
    });

    canvas.addEventListener('mouseup', () => {
      endDrag();
    });

    canvas.addEventListener('touchstart', (e) => {
      startDrag(e.touches[0].clientX, e.touches[0].clientY);
    });

    canvas.addEventListener('touchend', () => {
      endDrag();
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      e.stopImmediatePropagation();
      drag(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'p') {
        scene.paused = !scene.paused;
      } else if (e.key === 'm') {
        scene.paused = false;
        simulate(scene.dt);
        scene.paused = true;
      } else if (e.key === 'g') {
        scene.showGrid = !scene.showGrid;
      }
    });

    let lastTime = performance.now();
    let accumulator = 0.0;
    const maxFrameTime = 0.1;

    function simulate(dt) {
      if (scene.paused || !scene.fluid) return;

      scene.fluid.simulate(
        dt,
        scene.gravity,
        scene.flipRatio,
        scene.numPressureIters,
        scene.numParticleIters,
        scene.overRelaxation,
        scene.compensateDrift,
        scene.separateParticles,
        scene.obstacleX,
        scene.obstacleY,
        scene.obstacleRadius
      );
    }

    function update(currentTime) {
      const deltaTime = Math.min((currentTime - lastTime) / 1000, maxFrameTime);
      lastTime = currentTime;

      if (!scene.paused) {
        accumulator += deltaTime * scene.host_timescale;

        while (accumulator >= scene.dt) {
          simulate(scene.dt);
          accumulator -= scene.dt;
        }
      }

      draw();
      requestAnimationFrame(update);
    }

    setupScene();
    lastTime = performance.now();
    requestAnimationFrame(update);
  </script>
</body>

</html>
